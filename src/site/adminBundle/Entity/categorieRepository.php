<?php

namespace site\adminBundle\Entity;

use site\adminBundle\Entity\EntityBaseRepository;
use site\adminBundle\Entity\categorie;
use Gedmo\Tree\Traits\MaterializedPath;
use Gedmo\Tree\Traits\NestedSet;
use Gedmo\Tree\Traits\NestedSetEntity;

use Doctrine\ORM\QueryBuilder;
use Doctrine\ORM\Tools\Pagination\Paginator;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\ClassMetadata;

use site\adminBundle\services\aetools;
use site\adminBundle\services\aeDebug;
use \Exception;

/**
 * categorieRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
// class categorieRepository extends SortableRepository {
class categorieRepository extends EntityBaseRepository {

	protected $icons;
	protected $aetools;
	protected $aeDebug;

	// public function __construct(EntityManager $em, ClassMetadata $class) {
	// 	parent::__construct($em, $class);
	// }


	public function findArrayTree($id = null, $types = 'all', $shortCutContext = false) {
		if(is_string($types)) $types = array($types);
		if(!is_array($types)) $types = array('all');
		$qb = $this->createQueryBuilder(self::ELEMENT);
		if($id != null) {
			if(is_object($id)) $id = $id->getId();
			$id = intval($id);
			if($id > 0) $qb->where(self::ELEMENT.'.id = :id')->setParameter('id', $id);
		} else {
			$this->getRoots($qb);
		}
		$this->selectCategoriesForTree($qb, self::ELEMENT, $shortCutContext);
		$results = $qb->getQuery()->getScalarResult();
		$results = $this->addChildrenInTree($results, $types, $shortCutContext);
		return $results;
	}

	protected function addChildrenInTree($elements, $types, $shortCutContext = false) {
		$this->compileForTree($elements);
		foreach ($elements as $key => $element) {
			// 1ère passe
			$qb = $this->_em->createQueryBuilder(self::ELEMENT)->from('site\adminBundle\Entity\categorie', self::ELEMENT);
			if($shortCutContext == false) $this->contextStatut($qb, self::ELEMENT);
			$qb->join(self::ELEMENT.'.nestedpositionParents', 'nestpos')
				->join('nestpos.parent', 'parent')
				->where($qb->expr()->in('parent.id', $element['id']))
				// ->orderBy('nestpos.position', 'ASC')
				// select…
				->select(self::ELEMENT.'.id id')
				->addSelect(self::ELEMENT.' class_name')
				// groupBy
				->groupBy(self::ELEMENT.'.id')
				;
			$passe1 = $qb->getQuery()->getScalarResult();
			// 2ème passe
			foreach ($passe1 as $key2 => $passe) {
				switch ($passe['element_class_name']) {
					case 'categorie':
						$qb = $this->createQueryBuilder(self::ELEMENT);
						$qb->where(self::ELEMENT.'.id = :id')->setParameter('id', $passe['id']);
						$this->selectCategoriesForTree($qb, self::ELEMENT, true); // $shortCutContext déjà opéré en passe1
						$res = $qb->getQuery()->getScalarResult();
						if(is_array($res)) if(count($res) > 0) {
							if(!isset($elements[$key]['children'])) $elements[$key]['children'] = array();
							$elements[$key]['children'] = array_merge($elements[$key]['children'], $this->addChildrenInTree($res, $types, $shortCutContext));
						}
						break;
					default:
						if(in_array($passe['element_class_name'], $types) || in_array('all', $types)) {
							$qb = $this->_em->createQueryBuilder(self::ELEMENT)->from('site\adminBundle\Entity\nested', self::ELEMENT);
							$qb->where(self::ELEMENT.'.id = :id')->setParameter('id', $passe['id']);
							$this->selectBaseSubEntitiesForTree($qb, self::ELEMENT, true); // $shortCutContext déjà opéré en passe1
							$res = $qb->getQuery()->getScalarResult();
							if(is_array($res)) if(count($res) > 0) {
								if(!isset($elements[$key]['children'])) $elements[$key]['children'] = array();
								$elements[$key]['children'] = array_merge($elements[$key]['children'], $this->compileForTree($res));
							}
						}
						break;
				}
			}
		}
		return $elements;
	}

	protected function selectCategoriesForTree(&$qb, $elem, $shortCutContext = false) {
		if($shortCutContext == false) $this->contextStatut($qb, $elem);
		$qb->select($elem.'.id id')
			->addSelect($elem.'.nom text')
			// ->addSelect($elem.'.icon icon')
			->addSelect($elem.'.open opened')
			->addSelect($elem.'.couleur color')
			->addSelect($elem.'.type type_accept')
			->addSelect($elem.'.accepts valid_children')
			;
		// statut
		if(!$this->aliasExists($qb, 'statut')) $qb->join($elem.'.statut', 'statut');
		$qb->addSelect('statut.niveau niveau')
			->addSelect('statut.bundles bundles')
			;
		// class_name + groupBy
		$qb->addSelect($elem.' class_name')
			->groupBy($elem.'.id')
			;
	}
	protected function selectBaseSubEntitiesForTree(&$qb, $elem, $shortCutContext = false) {
		if($shortCutContext == false) $this->contextStatut($qb, $elem);
		$qb->select($elem.'.id id')
			->addSelect($elem.'.nom text')
			// ->addSelect($elem.'.icon icon')
			->addSelect($elem.'.couleur color')
			;
		// statut
		if(!$this->aliasExists($qb, 'statut')) $qb->join($elem.'.statut', 'statut');
		$qb->addSelect('statut.niveau niveau')
			->addSelect('statut.bundles bundles')
			;
		// class_name + groupBy
		$qb->addSelect($elem.' class_name')
			->groupBy($elem.'.id')
			;
	}

	protected function compileForTree(&$elements) {
		$fields = array(
			'opened' => array('categorie'),
			// 'icon' => array('all'),
			'valid_children' => array('categorie'),
			'bundles' => array('all'),
			'element_class_name' => array('all'),
		);
		foreach ($elements as $key => $element) {
			foreach ($fields as $field => $class) {
				if(in_array($element['element_class_name'], $class) || in_array('all', $class)) {
					switch ($field) {
						// case 'icon':
						// 	if(isset($elements[$key][$field])) {
						// 		if(is_string($elements[$key][$field])) $elements[$key][$field] .= ' fa';
						// 			else $elements[$key][$field] = $this->icons['element_class_name'];
						// 	} else $elements[$key][$field] = $this->icons['element_class_name'];
						// 	break;
						case 'valid_children':
							if(isset($elements[$key][$field])) $elements[$key][$field] = json_decode($elements[$key][$field]);
							break;
						case 'opened':
							if(isset($elements[$key][$field])) $elements[$key]['state'] = array($field => (boolean) $elements[$key][$field]);
								else $elements[$key]['state'] = array($field => false);
							unset($elements[$key][$field]);
							break;
						case 'element_class_name':
							$elements[$key]['type'] = $elements[$key][$field];
							unset($elements[$key][$field]);
							break;
						default:
							if(isset($elements[$key][$field])) {
								if(unserialize($elements[$key][$field]) != null) {
									$elements[$key][$field] = unserialize($elements[$key][$field]);
								} else {
									$elements[$key][$field] = array();
								}
							}
							break;
					}
				}
			}
		}
		return $elements;
	}

	// protected function selectCategoriesForTree(&$qb, $elem, $shortCutContext = false) {
	// 	$qb->select($elem.'.id id');
	// 	// context by statut
	// 	if($shortCutContext == false) $this->contextStatut($qb, $elem);
	// 	$validFields = $this->getFields();
	// 	$fields = array(
	// 		// single
	// 		// 'id' => 'id', // id inutile / déjà précisé en début de méthode
	// 		'nom' => 'text',
	// 		'open' => 'opened',
	// 		'couleur' => 'color',
	// 		'type' => 'type_accept',
	// 		// association
	// 		// 'subEntitys' => array('id' => 'subEntitysId'),
	// 		'statut' => array('niveau' => 'niveau', 'bundles' => 'bundles'),
	// 		// 'stat' => array('niveau', 'bundles'),
	// 		);
	// 	foreach ($fields as $field => $name) {
	// 		if(!is_string($field) && is_array($name)) {
	// 			throw new Exception("Champ manquant : vous devez préciser le nom ou l'alias du champ pour ".json_encode($name).".", 1);
	// 		}
	// 		if(!is_string($field) && is_string($name)) $field = $name;
	// 		if(!is_array($name)) $names = array($name); else $names = $name;
	// 		if('single' === $validFields[$field]['type']) {
	// 			// FIELD (single)
	// 			foreach ($names as $name => $dataName) {
	// 				$qb->addSelect($elem.'.'.$field.' '.$dataName);
	// 			}
	// 		} else if('association' === $validFields[$field]['type']) {
	// 			// ALIAS (association)
	// 			// création de l'alias s'il n'existe pas
	// 			if(!$this->aliasExists($qb, $field)) $qb->join($elem.'.'.$field, $field);
	// 			foreach ($names as $name => $dataName) {
	// 				$qb->addSelect($field.'.'.$name.' '.$dataName);
	// 			}
	// 		} else {
	// 			// throw new Exception("- ".$elem." : champ \"".$field."\" indéfini !", 1);
	// 		}
	// 	}
	// 	// add class_name column
	// 	$qb->addSelect($elem.' class_name');
	// 	// groupBy
	// 	$qb->addGroupBy($elem.'.id');
	// }

	// public function findSimpleScalarArticles($onlyActive = false) {
	// 	$qb = $this->createQueryBuilder(self::ELEMENT)
	// 		->join(self::ELEMENT.'.statut', 's')
	// 		->leftJoin(self::ELEMENT.'.serialnumbers', 'sery')
	// 		->leftJoin('sery.user', 'user')
	// 		->select(
	// 			self::ELEMENT.'.id id',
	// 			self::ELEMENT.'.nom nom',
	// 			self::ELEMENT.'.slug slug',
	// 			's.nom statut_nom',
	// 			'count(sery.id) number_series',
	// 			'count(user.id) number_users'
	// 			)
	// 		->groupBy(self::ELEMENT.'.id')
	// 		;
	// 	if($onlyActive === true) $qb = $this->defaultStatut($qb);
	// 	return $qb->getQuery()->getScalarResult();
	// }

	/**
	 * Renvoie les éléments root de catégories
	 * @param boolean $shortCutContext = false
	 * @return array
	 */
	public function findForList($shortCutContext = false) {
		return $this->findAll($shortCutContext);
		// return $this->findRoots($shortCutContext);
	}

	/**
	 * Renvoie les éléments root de catégories
	 * @param string/array $types = null
	 * @param boolean $shortCutContext = false
	 * @return array
	 */
	public function findRoots($types = null, $shortCutContext = false) {
		$qb = $this->createQueryBuilder(self::ELEMENT);
		if($types != null) $this->getElementsBySubType($types, $qb, $shortCutContext);
			else if($shortCutContext == false) $this->contextStatut($qb);
		$this->getRoots($qb);
		return $qb->getQuery()->getResult();
	}

	/**
	 * Renvoie les collections (niveau 2) de type
	 * @param string/array $types = null
	 * @param boolean $shortCutContext = false
	 * @return array
	 */
	public function findCollectionsByType($type = null, $level = null, $shortCutContext = false) {
		$qb = $this->createQueryBuilder(self::ELEMENT);
		// if($types != null) $this->getElementsBySubType($types, $qb, $shortCutContext);
		$qb->where(self::ELEMENT.'.type = :type')
			->setParameter('type', $type);
		if($level != null) $this->getByLevel((integer)$level, $qb);
			else $this->getNotRoots($qb);
		if($shortCutContext == false) $this->contextStatut($qb);
		return $qb->getQuery()->getResult();
	}

	/**
	 * Renvoie les éléments root de catégories
	 * @param boolean $shortCutContext = false
	 * @return array
	 */
	public function findLevel($level = 0, $types = null, $shortCutContext = false) {
		$qb = $this->createQueryBuilder(self::ELEMENT);
		if($types != null) $this->getElementsBySubType($types, $qb, $shortCutContext);
		if($shortCutContext == false) $this->contextStatut($qb);
		$this->getByLevel($level, $qb);
		return $qb->getQuery()->getResult();
	}



	/********************************/
	/*** CLOSURES                 ***/
	/********************************/

	// Select selon ACCEPT / But root
	public function getElementsBySubTypeButRoot($types, &$qb = null, $shortCutContext = false) {
		$qb = $this->getElementsBySubType($types, $qb, $shortCutContext);
		return $this->getNotRoots($qb);
	}

	// Select selon ACCEPT
	public function getElementsBySubType($types, &$qb = null, $shortCutContext = false) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		if(is_string($types)) $types = array($types);
		foreach ($types as $type) {
			$qb->orWhere($qb->expr()->orX($qb->expr()->like(self::ELEMENT.'.accepts', $qb->expr()->literal('%'.$type.'%'))));
		}
		if($shortCutContext == false) $this->contextStatut($qb);
		// resultat
		return $qb;
	}

	public function getElementsByTypeButRoot($types, &$qb = null, $shortCutContext = false) {
		$qb = $this->getElementsByType($types, $qb, $shortCutContext);
		return $this->getNotRoots($qb);
	}

	public function getElementsByType($types, &$qb = null, $shortCutContext = false) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		if(is_string($types)) $types = array($types);
		foreach ($types as $type) {
			$qb->orWhere(self::ELEMENT.'.type = :type')->setParameter('type', $type);
		}
		if($shortCutContext == false) $this->contextStatut($qb);
		// resultat
		return $qb;
	}


	public function getElementsButCategories($categories, &$qb = null) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		if(is_object($categories)) $categories = array($categories);
		foreach ($categories as $categorie) if($categorie->getId() != null) {
			$qb->andWhere(self::ELEMENT.'.id != :id')
				->setParameter('id', $categorie->getId())
			;
		}
		// resultat
		return $qb;
	}

	public function getByLevel($level = 0, &$qb = null) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		$qb->andWhere(self::ELEMENT.'.lvl = :level')
			->setParameter('level', intval($level))
			;
		// resultat
		return $qb;
	}

	public function getRoots(&$qb = null) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		$qb->andWhere(self::ELEMENT.'.lvl = 0');
		// resultat
		return $qb;
	}

	public function getNotRoots(&$qb = null) {
		if($qb == null) $qb = $this->createQueryBuilder(self::ELEMENT);
		$qb->andWhere(self::ELEMENT.'.lvl != 0');
		// resultat
		return $qb;
	}





}
